require('./base_plotter.js')

window.$doseResponsePlotterForm = (url, target, data) => {
  var $form = $('form#doseResponsePlotterForm')
  if ($form.length < 1) {
    $form = $(`<form action="${url}" id="doseResponsePlotterForm" target="${target}" method="post"></form>`)
    // target is basically a constant, url is generated by us, not users
    $('body').append($form) // eslint-disable-line jquery-unsafe/no-append
  } else {
    $form.html('') // eslint-disable-line jquery-unsafe/no-html
  }
  Object.keys(data).forEach(function (key) {
    const value = data[key]
    // key is from data from attributes generated by us
    $form.append(() => { // eslint-disable-line jquery-unsafe/no-append
      const $element = $(`<input name="${key}" type="hidden">`)
      $element.val(value)
      return $element
    })
  })
  return $form
}

// In order to put content into a new window, I had to create a form and submit it.
// I could not get writing the results of an xhr to the new window to work (nonce issues).
window.openDoseResponseWindow = function (element) {
  const $element = $(element)
  const url = $element.attr('dose-response-app')
  const windowOptions = 'resizable,scrollbars,width=1024,height=600'
  const target = 'dose_response_plotter'
  const doseResponseAppWindow = window.open('', target, windowOptions)
  doseResponseAppWindow.__isChildWindow = true
  doseResponseAppWindow.focus()
  const remote_hash = $element.data('remote')
  const $form = window.$doseResponsePlotterForm(url, target, remote_hash)
  $form.submit().remove()

  // Listen for reload notifications [from the miniapp]
  const BroadcastChannel = require('broadcast-channel').default
  window.rowReloaderChannel = window.rowReloaderChannel || new BroadcastChannel('RELOAD_ROW_ID', { webWorkerSupport: false })
  window.rowReloaderChannel.onmessage = (msg) => {
    CDD.reloadSearchResultRow(msg)
  }
}

$(document).on('click', '[dose-response-app]', function (event) {
  window.openDoseResponseWindow(event.currentTarget)
})

CDD.doseResponsePlotFormChangeTracker = (function () {
  var originalForm, formElement

  var formChanged = function () {
    return originalForm !== formElement.serialize()
  }

  return {
    formChanged: formChanged,
    setup: function (formId) {
      formElement = $('#' + formId)
      originalForm = formElement.serialize()
      window.onbeforeunload = function (e) { if (formChanged()) { return 'Changes have not been saved' } }
    },
  }
})()

// Only done if a point was toggled
CDD.reloadSearchResultRow = (function () {
  var targetRowId = null

  var reloadRowIfNecessary = function (e) {
    if (targetRowId === null) { return }
    // window.opener.window.CDD.reloadSearchResultRow(targetRowId)
    // Post reload notification [to the search page]
    const BroadcastChannel = require('broadcast-channel').default
    const channel = new BroadcastChannel('RELOAD_ROW_ID', { webWorkerSupport: false })
    channel.postMessage(targetRowId)
    channel.close()
    targetRowId = null
  }

  // Update the search result row when
  $(window).on('beforeunload', reloadRowIfNecessary) // the user clicks on the see plot tab, reloads or closes the mini-app.
  $(window).on('blur', reloadRowIfNecessary) // the user switches back to the search results page

  return function (moleculeId) {
    targetRowId = moleculeId
  }
})()

window.DoseResponsePlotter = function (divName) {
  BasePlotter.call(this, divName)
}

DoseResponsePlotter.prototype = Object.create(BasePlotter.prototype)
DoseResponsePlotter.prototype.constructor = DoseResponsePlotter

DoseResponsePlotter.prototype.setup = function (plotData, editingOutliers) {
  this.editingOutliers = editingOutliers
  BasePlotter.prototype.setup.call(this)
  $.extend(this, plotData)

  if (editingOutliers) {
    this.plot.onAfterSelectPoint = this._onPointSelection.bind(this)
  }

  this._setupPlotData()
  this._draw()
}

DoseResponsePlotter.prototype.chartOptions = function () {
  var options = BasePlotter.prototype.chartOptions.call(this)
  options.show_hints = false // Needed to prevent point and outlier series from showing hints when hovering or selecting a point
  if (!this.editingOutliers) {
    options.axis_left.cursor_position = options.axis_bottom.cursor_position = { show: true, color: '#1262B3' }
  }
  var EngineeringNotationFormatter = function () {
    EJSC.Formatter.__extendTo(this)

    this.numberOfDigits = function (value) {
      return (Math.round(Math.abs(Math.log(Math.abs(value)) / Math.log(10))) + 1)
    }
    this.format = function (value) {
      if (value === 0) {
        return '0'
      }
      if (value == Infinity) {
        return null
      }

      var absValue = Math.abs(value)
      if (absValue >= 1000 || absValue < 0.01 && absValue !== 0) {
        var exponent = Math.floor(((Math.log(absValue) / Math.log(10)) / 3).toPrecision(5)) * 3
        var sigFigs = (value / Math.pow(10, exponent))
        var numDigits = this.numberOfDigits(sigFigs)
        if (absValue.toString().length > 4 && Math.round(absValue).toString().split('').slice(0, 3).indexOf('0') === -1) {
          numDigits = 3
        }
        return sigFigs.toPrecision(numDigits) + 'E' + exponent
      } else {
        if (value.toString().length > 4) {
          return value.toPrecision(3)
        } else {
          return value
        }
      }
    }
  }
  var engineeringNotationFormatter = new EngineeringNotationFormatter()
  var EngineeringNotationForLogValuesFormatter = function () {
    EJSC.Formatter.__extendTo(this)
    this.format = function (value) {
      return engineeringNotationFormatter.format(Math.pow(10, value))
    }
  }
  options.axis_left.formatter = engineeringNotationFormatter
  options.axis_bottom.formatter = new EngineeringNotationForLogValuesFormatter()
  options.axis_bottom.major_ticks = { min_interval: 1.0 }
  return options
}

DoseResponsePlotter.prototype._onPointSelection = function (point, series, chart, hintElement, hoverOrSelect) {
  if (hoverOrSelect == 'select') {
    series.doseResponseDataSeries.toggleOutlierState(point)
    this._draw()
  }
}

DoseResponsePlotter.prototype._setupPlotData = function () {
  this._buildSeries()
  this._buildAxes()
  this._addSeriesToPlot()
}

DoseResponsePlotter.prototype._buildSeries = function () {
  this.series = $.makeArray(this.series).map(function (seriesData) {
    return new DoseResponsePlotter.DataSeries(seriesData, this)
  }, this)
}

DoseResponsePlotter.prototype._buildAxes = function () {
  this.doseAxis = $.extend(this.plot.axis_bottom, DoseResponsePlotter.AxisExtension)
  this.doseAxis.setCaption(this.dose_label)
  this._setDoseAxisBoundaries()

  this.responseAxis = $.extend(this.plot.axis_left, DoseResponsePlotter.AxisExtension)
  this.responseAxis.setCaption(this.response_label)
  this._setResponseAxisBoundaries()
}

DoseResponsePlotter.prototype._addSeriesToPlot = function () {
  // Ordering of graphical data
  this.series.forEach(function (series) {
    series.addControlSeries(this.plot)
  }, this)

  this.series.forEach(function (series) {
    series.addSampleCurveSeries(this.plot)
  }, this)

  this.series.forEach(function (series) {
    series.addPointSeries(this.plot)
  }, this)
}

DoseResponsePlotter.prototype._setDoseAxisBoundaries = function () {
  this.dose_axis_min = Infinity
  this.dose_axis_max = -Infinity

  this.series.forEach(function (theSeries) {
    var seriesBoundaries = theSeries.doseBoundaries()
    this.dose_axis_min = Math.min(this.dose_axis_min, seriesBoundaries.min)
    this.dose_axis_max = Math.max(this.dose_axis_max, seriesBoundaries.max)
  }, this)

  var padding = 3 - (this.dose_axis_max - this.dose_axis_min) // ensure we always show at least 3 log units
  if (padding > 0) {
    this.dose_axis_min -= padding / 2
    this.dose_axis_max += padding / 2
  }

  this.doseAxis.setExtremes(this.dose_axis_min, this.dose_axis_max, false)
}

DoseResponsePlotter.prototype._setResponseAxisBoundaries = function () {
  this.response_axis_min = Infinity
  this.response_axis_max = -Infinity
  this.series.forEach(function (theSeries) {
    var seriesBoundaries = theSeries.responseBoundaries(this.dose_axis_min, this.dose_axis_max)
    this.response_axis_min = Math.min(this.response_axis_min, seriesBoundaries.min)
    this.response_axis_max = Math.max(this.response_axis_max, seriesBoundaries.max)
  }, this)
  if (this.response_axis_min == this.response_axis_max) {
    var buffer = Math.abs(this.response_axis_min / 2)
    this.response_axis_min = this.response_axis_min - buffer
    this.response_axis_max = this.response_axis_max + buffer
  }

  this.responseAxis.setExtremes(this.response_axis_min, this.response_axis_max, false)
}

DoseResponsePlotter.DataSeries = function (seriesData, plotter) {
  this.POSITIVE_CONTROL_COLOR = 'rgb(255, 180, 180)'
  this.REFERENCE_MOLECULE_COLOR = 'rgb(255, 204, 51)'
  $.extend(this, seriesData)
  this.plotter = plotter
}

DoseResponsePlotter.DataSeries.prototype.doseBoundaries = function () {
  var min = Infinity
  var max = -Infinity
  var updateBoundaries = function (value) {
    min = Math.min(min, value)
    max = Math.max(max, value)
  }

  $.makeArray(this.p).map(function (x) { return x.x }).forEach(updateBoundaries)
  $.makeArray(this.o).map(function (x) { return x.x }).forEach(updateBoundaries)

  return { min: min, max: max }
}

DoseResponsePlotter.DataSeries.prototype.responseBoundaries = function (doseMin, doseMax) {
  var min = Infinity
  var max = -Infinity
  var updateBoundaries = function (value) {
    min = Math.min(min, value)
    max = Math.max(max, value)
  }

  $.makeArray(this.p).map(function (x) { return x.y }).forEach(updateBoundaries)
  $.makeArray(this.o).map(function (x) { return x.y }).forEach(updateBoundaries)

  if (this.pos_cont_resp != null) { updateBoundaries(this.pos_cont_resp) }
  if (this.neg_cont_resp != null) { updateBoundaries(this.neg_cont_resp) }
  if (this.positiveControlFit() != null) {
    updateBoundaries(this.positiveControlFit().value(doseMin))
    updateBoundaries(this.positiveControlFit().value(doseMax))
  }
  if (this.referenceMoleculeFit() != null) {
    updateBoundaries(this.referenceMoleculeFit().value(doseMin))
    updateBoundaries(this.referenceMoleculeFit().value(doseMax))
  }

  return { min: min, max: max }
}

DoseResponsePlotter.DataSeries.prototype.addControlSeries = function (plot) {
  if (this.positiveControlFitSeries() != null) { plot.addSeries(this.positiveControlFitSeries(), false) }
  if (this.referenceMoleculeFitSeries() != null) { plot.addSeries(this.referenceMoleculeFitSeries(), false) }
}

DoseResponsePlotter.DataSeries.prototype.addSampleCurveSeries = function (plot) {
  if (this.sampleFitSeries() != null) {
    if (this.interceptSeries() != null) {
      this.interceptSeries().map(function (series) { plot.addSeries(series, false) })
    }
    plot.addSeries(this.sampleFitSeries(), false)
  }
}

DoseResponsePlotter.DataSeries.prototype.addPointSeries = function (plot) {
  plot.addSeries(this.outlierSeries(), false)
  plot.addSeries(this.pointSeries(), false)
}

DoseResponsePlotter.DataSeries.prototype.outlierSeries = function () {
  if (this._outlierSeries === undefined) {
    this._outlierSeries = this._createScatterSeries(this.o, { pointStyle: 'cross', opacity: 50 })
  }
  return this._outlierSeries
}

DoseResponsePlotter.DataSeries.prototype.pointSeries = function () {
  if (this._pointSeries === undefined) {
    this._pointSeries = this._createScatterSeries(this.p, { pointStyle: 'box', opacity: 100 })
  }
  return this._pointSeries
}

DoseResponsePlotter.DataSeries.prototype.sampleFitSeries = function () {
  if (this._sampleFitSeries === undefined && this.sampleFit() != null) {
    this._sampleFitSeries = this._createFitSeries(this.sampleFit(), { lineWidth: 2, color: this.color })
  }
  return this._sampleFitSeries
}

DoseResponsePlotter.DataSeries.prototype.interceptSeries = function () {
  if (this._interceptSeries === undefined && this.sampleFit() != null && this.x != null) {
    this._interceptSeries = _.chain(this.x).map((intercept) => { return this._createInterceptSeries(intercept) }, this).compact().value()
  }
  return this._interceptSeries
}

DoseResponsePlotter.DataSeries.prototype.positiveControlFitSeries = function () {
  if (this._positiveControlFitSeries === undefined && this.positiveControlFit() != null) {
    this._positiveControlFitSeries = this._createFitSeries(this.positiveControlFit(), { lineWidth: 1, color: this.POSITIVE_CONTROL_COLOR })
  }
  return this._positiveControlFitSeries
}

DoseResponsePlotter.DataSeries.prototype.referenceMoleculeFitSeries = function () {
  if (this._referenceMoleculeFitSeries === undefined && this.referenceMoleculeFit() != null) {
    this._referenceMoleculeFitSeries = this._createFitSeries(this.referenceMoleculeFit(), { lineWidth: 1, color: this.REFERENCE_MOLECULE_COLOR })
  }
  return this._referenceMoleculeFitSeries
}

DoseResponsePlotter.DataSeries.prototype.sampleFit = function () {
  if (this._sampleFit === undefined && this.center != null) {
    this._sampleFit = new DoseResponsePlotter.HillEquation({ min: this.min, max: this.max, center: this.center, slope: this.slope })
  }
  return this._sampleFit
}

DoseResponsePlotter.DataSeries.prototype.positiveControlFit = function () {
  if (this._positiveControlFit === undefined && this.cont_center != null) {
    this._positiveControlFit = new DoseResponsePlotter.HillEquation({ min: this.cont_min, max: this.cont_max, center: this.cont_center, slope: this.cont_slope })
  }
  return this._positiveControlFit
}

DoseResponsePlotter.DataSeries.prototype.referenceMoleculeFit = function () {
  if (this._referenceMoleculeFit === undefined && this.ref_center != null) {
    this._referenceMoleculeFit = new DoseResponsePlotter.HillEquation({ min: this.ref_min, max: this.ref_max, center: this.ref_center, slope: this.ref_slope })
  }
  return this._referenceMoleculeFit
}

DoseResponsePlotter.DataSeries.prototype.toggleOutlierState = function (point) {
  var targetSeries = (point.__owner === this.pointSeries()) ? this.outlierSeries() : this.pointSeries()
  var hiddenOutlierField = $('#readout_' + point.userdata + '_outlier_type')
  targetSeries.acquirePoint(point)

  if (hiddenOutlierField.length > 0) { hiddenOutlierField[0].value = targetSeries === this.outlierSeries() ? '1' : '0' }
}

DoseResponsePlotter.DataSeries.prototype._createFitSeries = function (hillEquation, options) {
  return new EJSC.FunctionSeries(hillEquation.seriesFunction(), $.extend({ lineWidth: 1, drawPoints: false, legendIsVisible: false, hint_string: '', selectable: false }, options))
}

DoseResponsePlotter.DataSeries.prototype._createScatterSeries = function (dataPoints, options) {
  var convertedDataPoints = $.makeArray(dataPoints).map(function (point) {
    return [point.x, point.y, null, point.readout_id, point.standard_error_of_the_mean]
  })
  var scatterSeries = new EJSC.ScatterSeries(new EJSC.ArrayDataHandler(convertedDataPoints), $.extend({ pointSize: 4, delayLoad: false, color: this.color, padding: { x_axis_min: 20, x_axis_max: 20, y_axis_min: 20, y_axis_max: 20 } }, options))
  scatterSeries.doseResponseDataSeries = this
  return scatterSeries
}

DoseResponsePlotter.DataSeries.prototype._createInterceptSeries = function (intercept) {
  var doseBoundaries = this.plotter.doseAxis.getExtremes()
  if (intercept <= doseBoundaries.min || doseBoundaries.max <= intercept) { return null }

  var points = [
    [this.plotter.doseAxis.getOutOfBoundMin(), this.sampleFit().value(intercept)],
    [intercept, this.sampleFit().value(intercept)],
    [intercept, this.plotter.responseAxis.getOutOfBoundMin()],
  ]
  return new EJSC.LineSeries(new EJSC.ArrayDataHandler(points), { lineWidth: 1, drawPoints: false, legendIsVisible: false, hint_string: '', delayLoad: false, color: this.color, lineOpacity: 20 })
}

DoseResponsePlotter.HillEquation = function (fitParameters) {
  $.extend(this, fitParameters)
}

DoseResponsePlotter.HillEquation.prototype.value = function (x) {
  return this.min + (this.max - this.min) / (1.0 + Math.pow(10.0, -this.slope * (x - this.center)))
}

DoseResponsePlotter.HillEquation.prototype.seriesFunction = function () {
  return this.value.bind(this)
}

DoseResponsePlotter.AxisExtension = {
  getOutOfBoundMin: function () {
    return 2 * this.getExtremes().min - this.getExtremes().max
  },
}
